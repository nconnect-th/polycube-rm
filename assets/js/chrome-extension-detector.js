/**
 * Chrome Extension Detector
 * р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Бр╕ер╕░р╣Бр╕кр╕Фр╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е Chrome Extensions р╕Чр╕╡р╣Ир╕нр╕▓р╕Ир╕Ир╕░ inject р╣Ар╕Вр╣Йр╕▓р╕бр╕▓р╣Гр╕Щр╕лр╕Щр╣Йр╕▓р╣Ар╕зр╣Зр╕Ъ
 */

class ChromeExtensionDetector {
    constructor() {
        this.detectedExtensions = [];
        this.mutationObserver = null;
        this.init();
    }

    init() {
        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Чр╕▒р╕Щр╕Чр╕╡р╕лр╕ер╕▒р╕Зр╣Вр╕лр╕ер╕Фр╕лр╕Щр╣Йр╕▓р╣Ар╕зр╣Зр╕Ъ
        this.detectInjectedContent();
        
        // р╕Хр╕▒р╣Йр╕З MutationObserver р╣Ар╕Юр╕╖р╣Ир╕нр╕Хр╕┤р╕Фр╕Хр╕▓р╕бр╕Бр╕▓р╕гр╣Ар╕Ыр╕ер╕╡р╣Ир╕вр╕Щр╣Бр╕Ыр╕ер╕З DOM
        this.setupMutationObserver();
        
        // р╣Бр╕кр╕Фр╕Зр╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М
        this.displayResults();
    }

    detectInjectedContent() {
        console.log('ЁЯФН р╕Бр╕│р╕ер╕▒р╕Зр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ Chrome Extensions...');
        
        // 1. р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ chrome-extension:// URLs
        this.detectChromeExtensionURLs();
        
        // 2. р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ elements р╕Чр╕╡р╣Ир╕бр╕╡ ID р╕лр╕гр╕╖р╕н class р╕Чр╕╡р╣Ир╣Др╕бр╣Ир╣Гр╕Кр╣Ир╕Вр╕нр╕Зр╣Ар╕зр╣Зр╕Ъ
        this.detectSuspiciousElements();
        
        // 3. р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ CSS р╕Чр╕╡р╣Ир╕Цр╕╣р╕Б inject
        this.detectInjectedCSS();
        
        // 4. р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ Scripts р╕Чр╕╡р╣Ир╕Цр╕╣р╕Б inject
        this.detectInjectedScripts();
        
        // 5. р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ Known Extension Patterns
        this.detectKnownExtensionPatterns();
    }

    detectChromeExtensionURLs() {
        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Гр╕Щ stylesheet links
        const links = document.querySelectorAll('link[href*="chrome-extension://"]');
        links.forEach(link => {
            const extensionId = this.extractExtensionId(link.href);
            this.addDetectedExtension(extensionId, 'CSS Link', link.href);
        });

        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Гр╕Щ script sources
        const scripts = document.querySelectorAll('script[src*="chrome-extension://"]');
        scripts.forEach(script => {
            const extensionId = this.extractExtensionId(script.src);
            this.addDetectedExtension(extensionId, 'Script', script.src);
        });

        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Гр╕Щ images
        const images = document.querySelectorAll('img[src*="chrome-extension://"]');
        images.forEach(img => {
            const extensionId = this.extractExtensionId(img.src);
            this.addDetectedExtension(extensionId, 'Image', img.src);
        });
    }

    detectSuspiciousElements() {
        // Known extension element patterns
        const suspiciousSelectors = [
            '[id*="floik"]',
            '[id*="extension"]',
            '[class*="floik"]',
            '[class*="extension"]',
            'grammarly-desktop-integration',
            'utilengine-app',
            '[id*="super"]',
            '[id*="dev"]',
            '[data-grammarly-shadow-root]'
        ];

        suspiciousSelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
                const info = {
                    tagName: element.tagName,
                    id: element.id,
                    className: element.className,
                    innerHTML: element.innerHTML.substring(0, 100) + '...'
                };
                this.addDetectedExtension('Unknown', 'DOM Element', JSON.stringify(info));
            });
        });
    }

    detectInjectedCSS() {
        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ style tags р╕Чр╕╡р╣Ир╣Др╕бр╣Ир╣Др╕Фр╣Йр╕нр╕вр╕╣р╣Ир╣Гр╕Щ source code р╣Ар╕Фр╕┤р╕б
        const styleTags = document.querySelectorAll('style');
        styleTags.forEach(style => {
            const content = style.textContent || style.innerHTML;
            
            // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ known extension CSS patterns
            if (content.includes('floik') || 
                content.includes('extension') || 
                content.includes('grammarly') ||
                content.includes('utilengine')) {
                
                this.addDetectedExtension(
                    'Unknown', 
                    'Injected CSS', 
                    content.substring(0, 200) + '...'
                );
            }
        });
    }

    detectInjectedScripts() {
        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ script tags р╕Чр╕╡р╣Ир╕нр╕▓р╕Ир╕Ир╕░р╕Цр╕╣р╕Б inject
        const scripts = document.querySelectorAll('script:not([src])');
        scripts.forEach(script => {
            const content = script.textContent || script.innerHTML;
            
            // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ patterns р╕Чр╕╡р╣Ир╕нр╕▓р╕Ир╕Ир╕░р╣Ар╕Ыр╣Зр╕Щр╕Вр╕нр╕З extension
            if (content.includes('chrome.runtime') || 
                content.includes('browser.runtime') ||
                content.includes('extension') ||
                content.includes('content_script')) {
                
                this.addDetectedExtension(
                    'Unknown', 
                    'Injected Script', 
                    content.substring(0, 200) + '...'
                );
            }
        });
    }

    detectKnownExtensionPatterns() {
        // р╕гр╕▓р╕вр╕Бр╕▓р╕г extension patterns р╕Чр╕╡р╣Ир╕гр╕╣р╣Йр╕Ир╕▒р╕Б
        const knownPatterns = {
            'floik': 'Floik Extension (Screen Recording/Annotation)',
            'grammarly': 'Grammarly Writing Assistant',
            'utilengine': 'UtilEngine Extension',
            'adblock': 'AdBlock Extension',
            'lastpass': 'LastPass Password Manager',
            'metamask': 'MetaMask Wallet',
            'honey': 'Honey Coupon Extension'
        };

        Object.keys(knownPatterns).forEach(pattern => {
            const found = document.querySelector(`[id*="${pattern}"], [class*="${pattern}"]`);
            if (found) {
                this.addDetectedExtension(
                    pattern, 
                    'Known Extension', 
                    knownPatterns[pattern]
                );
            }
        });
    }

    setupMutationObserver() {
        this.mutationObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ node р╣Гр╕лр╕бр╣Ир╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╣Ар╕Юр╕┤р╣Ир╕бр╣Ар╕Вр╣Йр╕▓р╕бр╕▓
                        this.checkNewNode(node);
                    }
                });
            });
        });

        this.mutationObserver.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['id', 'class']
        });
    }

    checkNewNode(node) {
        // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ node р╣Гр╕лр╕бр╣Ир╕зр╣Ир╕▓р╕бр╕▓р╕Ир╕▓р╕Б extension р╕лр╕гр╕╖р╕нр╣Др╕бр╣И
        const suspiciousPatterns = ['floik', 'extension', 'grammarly', 'utilengine'];
        
        suspiciousPatterns.forEach(pattern => {
            if (node.id && node.id.includes(pattern) ||
                node.className && node.className.includes(pattern)) {
                
                console.log('ЁЯЪи р╕Хр╕гр╕зр╕Ир╕Юр╕Ъ Extension Element р╣Гр╕лр╕бр╣И:', {
                    tagName: node.tagName,
                    id: node.id,
                    className: node.className
                });
                
                this.addDetectedExtension(
                    pattern,
                    'Dynamically Added',
                    `${node.tagName} - ${node.id || node.className}`
                );
            }
        });
    }

    extractExtensionId(url) {
        const match = url.match(/chrome-extension:\/\/([a-z]{32})\//);
        return match ? match[1] : 'unknown';
    }

    addDetectedExtension(id, type, details) {
        const existing = this.detectedExtensions.find(ext => 
            ext.id === id && ext.type === type && ext.details === details
        );
        
        if (!existing) {
            this.detectedExtensions.push({
                id,
                type,
                details,
                timestamp: new Date().toISOString()
            });
        }
    }

    displayResults() {
        setTimeout(() => {
            console.group('ЁЯУК р╕Ьр╕ер╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ Chrome Extensions');
            
            if (this.detectedExtensions.length === 0) {
                console.log('тЬЕ р╣Др╕бр╣Ир╕Юр╕Ъ Chrome Extensions р╕Чр╕╡р╣И inject р╣Ар╕Вр╣Йр╕▓р╕бр╕▓р╣Гр╕Щр╕лр╕Щр╣Йр╕▓р╣Ар╕зр╣Зр╕Ъ');
            } else {
                console.log(`ЁЯФН р╕Юр╕Ъ Chrome Extensions ${this.detectedExtensions.length} р╕гр╕▓р╕вр╕Бр╕▓р╕г:`);
                
                this.detectedExtensions.forEach((ext, index) => {
                    console.group(`${index + 1}. ${ext.type} - ${ext.id}`);
                    console.log('р╕гр╕▓р╕вр╕ер╕░р╣Ар╕нр╕╡р╕вр╕Ф:', ext.details);
                    console.log('р╣Ар╕зр╕ер╕▓:', ext.timestamp);
                    console.groupEnd();
                });
            }
            
            console.groupEnd();
            
            // р╕кр╕гр╣Йр╕▓р╕З report object р╣Ар╕Юр╕╖р╣Ир╕нр╣Гр╕лр╣Йр╣Ар╕Вр╣Йр╕▓р╕Цр╕╢р╕Зр╣Др╕Фр╣Йр╕Ир╕▓р╕Б console
            window.extensionDetectorReport = {
                totalFound: this.detectedExtensions.length,
                extensions: this.detectedExtensions,
                getReport: () => this.detectedExtensions,
                getKnownExtensions: () => this.detectedExtensions.filter(ext => ext.type === 'Known Extension')
            };
            
            console.log('ЁЯТб р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Фр╕╣р╕гр╕▓р╕вр╕Зр╕▓р╕Щр╣Бр╕Ър╕Ър╕ер╕░р╣Ар╕нр╕╡р╕вр╕Ф р╣Гр╕Кр╣Йр╕Др╕│р╕кр╕▒р╣Ир╕З: window.extensionDetectorReport.getReport()');
            
        }, 2000); // р╕гр╕н 2 р╕зр╕┤р╕Щр╕▓р╕Чр╕╡ р╣Ар╕Юр╕╖р╣Ир╕нр╣Гр╕лр╣Й DOM р╣Вр╕лр╕ер╕Фр╣Ар╕кр╕гр╣Зр╕И
    }

    destroy() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
    }
}

// р╣Ар╕гр╕┤р╣Ир╕бр╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Ар╕бр╕╖р╣Ир╕н DOM р╕Юр╕гр╣Йр╕нр╕б
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.chromeExtensionDetector = new ChromeExtensionDetector();
    });
} else {
    window.chromeExtensionDetector = new ChromeExtensionDetector();
}
